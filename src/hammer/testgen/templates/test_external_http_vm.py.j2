"""HAMMER Generated External HTTP Tests (VM-based).

Assignment: {{ assignment_id }}
Phase: {{ phase }}

Tests that verify HTTP endpoints are accessible from other VMs.
These tests run from specified VMs to test cross-VM HTTP connectivity.
"""

import pytest
import re


{% for test in tests %}
{% for host in test.hosts %}
@pytest.mark.{{ phase }}
@pytest.mark.weight({{ test.weight }})
def test_external_http_{{ test.safe_name }}_from_{{ host }}(host_{{ host }}):
    """Verify HTTP {{ test.method }} {{ test.url }} returns {{ test.expected_status }} from {{ host }}."""
    # Use curl to test HTTP endpoint
    cmd = host_{{ host }}.run(
        "curl -s -o /tmp/hammer_ext_http_response -w '%%{http_code}' "
        "-X {{ test.method }} "
        "--connect-timeout {{ test.timeout_seconds }} "
        "'{{ test.url | pyescape }}'"
    )

    assert cmd.rc == 0, f"curl command failed on {{ host }}: {cmd.stderr}"

    status_code = int(cmd.stdout.strip())
    assert status_code == {{ test.expected_status }}, \
        f"Expected status {{ test.expected_status }}, got {status_code} for {{ test.url | pyescape }} from {{ host }}"
{% if test.response_contains is not none %}

    # Check response body contains expected substring
    body_cmd = host_{{ host }}.run("cat /tmp/hammer_ext_http_response")
    assert "{{ test.response_contains | pyescape }}" in body_cmd.stdout, \
        f"Response body should contain '{{ test.response_contains | pyescape }}' when accessed from {{ host }}"
{% endif %}
{% if test.response_regex is not none %}

    # Check response body matches regex pattern
    body_cmd = host_{{ host }}.run("cat /tmp/hammer_ext_http_response")
    pattern = r"{{ test.response_regex | pyescape }}"
    assert re.search(pattern, body_cmd.stdout), \
        f"Response body should match pattern '{pattern}' when accessed from {{ host }}"
{% endif %}


{% endfor %}
{% endfor %}
